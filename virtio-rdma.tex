\section{RDMA Device}\label{sec:Device Types / RDMA Device}

The virtio RDMA device provide a virtual RDMA device supporting infiniband verbs.

This device ONLY support RoCEv2 now.

\subsection{Device ID}\label{sec:Device Types / RDMA Device / Device ID}
  42

\subsection{Virtqueues}\label{sec:Device Types / RDMA Device / Virtqueues}
\begin{description}
\item[0] control
\item[1] cq1
\item[\ldots] 
\item[N] cqN
\item[N+1] sq1
\item[N+2] rq1
\item[N+2M-1] sqM
\item[N+2M] rqM
\item[N+2M+1] srq1
\item[N+2M+X] srqX 
\end{description}

\subsection{Feature bits}\label{sec:Device Types / RDMA Device / Feature bits}

There are currently no feature bits defined for this device.

\subsection{Device configuration layout}\label{sec:Device Types / RDMA Device / Device configuration layout}

RDMA device configuration uses the following layout structure,
all of the following configuration fields currently defined are driver-read-only:

\begin{lstlisting}
struct virtio_rdma_config {
    /* FW version */
    le64 fw_ver;
    /* Node GUID (in network byte order) */
    le64 node_guid;
    /* System image GUID (in network byte order) */
    le64 sys_image_guid;
    /* Vendor ID, per IEEE */
    le32 vendor_id;
    /* Vendor supplied part ID */
    le32 vendor_part_id;
    /* Hardware version */
    le32 hw_ver;
    /* Largest contiguous block that can be registered */
    le64 max_mr_size;
    /* Supported memory shift sizes */
    le64 page_size_cap;
    /* Maximum number of supported QPs */
    le32 max_qp;
    /* Maximum number of outstanding WR on any work queue */
    le32 max_qp_wr;
    /* HCA capabilities mask */
    le64 device_cap_flags;
    /* Maximum number of s/g per WR for SQ for non RDMA Read operations */
    le32 max_send_sge;
    /* Maximum number of s/g per WR for RQ for non RDMA Read operations */
    le32 max_recv_sge; 
    /* Maximum number of s/g per WR for RDMA Read operations */
    le32 max_sge_rd; 
    /* Maximum number of supported CQs */
    le32 max_cq;
    /* Maximum number of CQE capacity per CQ */
    le32 max_cqe;
    /* Maximum number of supported MRs */
    le32 max_mr;
    /* Maximum number of supported PDs */
    le32 max_pd;
    /* Maximum number of RDMA Read & Atomic operations that can be outstanding per QP */
    le32 max_qp_rd_atom;
    /* Maximum number of RDMA Read & Atomic operations that can be outstanding per EEC */
    le32 max_ee_rd_atom;
    /* Maximum number of resources used for RDMA Read & Atomic operations by this HCA as the Target */
    le32 max_res_rd_atom;
    /* Maximum depth per QP for initiation of RDMA Read & Atomic operations */
    le32 max_qp_init_rd_atom;
    /* Maximum depth per EEC for initiation of RDMA Read & Atomic operations */
    le32 max_ee_init_rd_atom;
    /* Atomic operations support level */
    le32 atomic_cap;
    /* Maximum number of supported EE contexts */
    le32 max_ee;
    /* Maximum number of supported RD domains */
    le32 max_rdd;
    /* Maximum number of supported MWs */
    le32 max_mw;
    /* Maximum number of supported raw IPv6 datagram QPs */
    le32 max_raw_ipv6_qp;
    /* Maximum number of supported Ethertype datagram QPs */
    le32 max_raw_ethy_qp;
    /* Maximum number of supported multicast groups */
    le32 max_mcast_grp;
    /* Maximum number of QPs per multicast group which can be attached */
    le32 max_mcast_qp_attach;
    /* Maximum number of QPs which can be attached to multicast groups */
    le32 max_total_mcast_qp_attach;
    /* Maximum number of supported address handles */
    le32 max_ah;
    /* Maximum number of supported SRQs */
    le32 max_srq;
    /* Maximum number of WRs per SRQ */
    le32 max_srq_wr;
    /* Maximum number of s/g per SRQ */
    le32 max_srq_sge;
    /* Maximum number page list length for fast registration operation */
    le32 max_fast_reg_page_list_len;
    /* Maximum number page list length for PI (protection information) fast registration operation */
    le32 max_pi_fast_reg_page_list_len;
    /* Maximum number of partitions */
    le16 max_pkeys;
    /* Local CA ack delay */
    u8 local_ca_ack_delay;
    /* Number of physical ports */
    u8 phys_port_cnt;
    /* Reserved for future */
    le64 reserved[64];
};
\end{lstlisting}

The HCA capabilities are currently defined for the device_cap_flags field:

\begin{lstlisting}
enum ib_device_cap_flags {
    /* Support Bad P_Key Counter */
    VIRTIO_IB_DEVICE_BAD_PKEY_CNTR = (1 << 1),
    /* Support Q_Key violation counter */
    VIRTIO_IB_DEVICE_BAD_QKEY_CNTR = (1 << 2),
    /* Support Automatic Path Migration */
    VIRTIO_IB_DEVICE_AUTO_PATH_MIG = (1 << 4),
    /* Support changing the QP's primary port number */
    VIRTIO_IB_DEVICE_CHANGE_PHY_PORT = (1 << 5),
    /* Support enforcements of the port number of Address Handle (UD QP) */
    VIRTIO_IB_DEVICE_UD_AV_PORT_ENFORCE = (1 << 6),
    /* Support modifying the current QP state */
    VIRTIO_IB_DEVICE_CURR_QP_STATE_MOD = (1 << 7),
    /* Support system image GUID */
    VIRTIO_IB_DEVICE_SYS_IMAGE_GUID = (1 << 11),
    /* Support RNR-NAK generation for RC QPs */
    VIRTIO_IB_DEVICE_RC_RNR_NAK_GEN = (1 << 12),
    /* Support notification when N Work Completions exists in the CQ */
    VIRTIO_IB_DEVICE_N_NOTIFY_CQ = (1 << 14),
    /* Support a per-device lkey */
    VIRTIO_IB_DEVICE_LOCAL_DMA_LKEY = (1 << 15),
    /* Support Memory Windows */
    VIRTIO_IB_DEVICE_MEM_WINDOW = (1 << 17),
    /* Support eXtended Reliable Connection */
    VIRTIO_IB_DEVICE_XRC = (1 << 20),
    /*
    * Support the IB "base memory management extension"
    * which includes support for fast registrations (IB_WR_REG_MR,
    * IB_WR_LOCAL_INV and IB_WR_SEND_WITH_INV verbs).
    */
    VIRTIO_IB_DEVICE_MEM_MGT_EXTENSIONS = (1 << 21),
    /* Support blocking multicast loopback */
    VIRTIO_IB_DEVICE_BLOCK_MULTICAST_LOOPBACK = (1 << 22),
    /* Support Memory Windows type 2A: association with a QPN */
    VIRTIO_IB_DEVICE_MEM_WINDOW_TYPE_2A = (1 << 23),
    /* Support Memory Windows type 2B: association with a QPN and PD */
    VIRTIO_IB_DEVICE_MEM_WINDOW_TYPE_2B = (1 << 24),
    /*
    * Support execution of WQEs that involve synchronization
    * of I/O operations with single completion queue managed
    * by hardware.
    */
    VIRTIO_IB_DEVICE_CROSS_CHANNEL = (1 << 27),
    /* Support device managed flow steering */
    VIRTIO_IB_DEVICE_MANAGED_FLOW_STEERING = (1 << 29),
    /* Support signature handover */
    VIRTIO_IB_DEVICE_INTEGRITY_HANDOVER = (1 << 30),
    /* support sg list mapping */
    VIRTIO_IB_DEVICE_SG_GAPS_REG = (1ULL << 32),
};
\end{lstlisting}

Three atomic capabilities are currently defined for the atomic_cap field:

\begin{lstlisting}
enum {
    VIRTIO_IB_ATOMIC_NONE,
    VIRTIO_IB_ATOMIC_HCA,
    VIRTIO_IB_ATOMIC_GLOB
};
\end{lstlisting}

\devicenormative{\subsubsection}{Device configuration layout}{Device Types / RDMA Device / Device configuration layout}

\begin{itemize*}
\item The device MUST set max_cq to between 1 and 16384 inclusive.
\item The device MUST set max_qp to between 1 and 16384 inclusive.
\item The device MUST set max_srq to between 0 and 16384 inclusive.
\end{itemize*}

\drivernormative{\subsubsection}{Device configuration layout}{Device Types / RDMA Device / Device configuration layout}

\begin{itemize*}
\item The driver MUST NOT write to config.
\end{itemize*}

\subsection{Device Initialization}\label{sec:Device Types / RDMA Device / Device Initialization}

The
\hyperref[sec:General Initialization And Device Operation / Device Initialization]{general
requirements on device initialization} apply.

\subsection{Device Operation: controlq}\label{sec:Device Types / RDMA Device / controlq Operation}

The control virtqueue is used for control path opeartion. Requests have the following format:

\begin{lstlisting}
struct virtio_rdma_ctrl_req {
    /* Device-readable part */
    u8 command;
    u8 command-specific-request-data[];
    
    /* Device-writable part */
    u8 response;
    u8 command-specific-response-data[];
};
\end{lstlisting}

Command identifies the request data and response data.

The following commands are defined:

\begin{lstlisting}
enum {
    VIRTIO_CMD_ILLEGAL,
    VIRTIO_CMD_QUERY_PORT,
    VIRTIO_CMD_CREATE_CQ,
    VIRTIO_CMD_DESTROY_CQ,
    VIRTIO_CMD_CREATE_PD,
    VIRTIO_CMD_DESTROY_PD,
    VIRTIO_CMD_GET_DMA_MR,
    VIRTIO_CMD_CREATE_MR,
    VIRTIO_CMD_MAP_MR_SG,
    VIRTIO_CMD_REG_USER_MR,
    VIRTIO_CMD_DEREG_MR,
    VIRTIO_CMD_CREATE_QP,
    VIRTIO_CMD_MODIFY_QP,
    VIRTIO_CMD_QUERY_QP,
    VIRTIO_CMD_DESTROY_QP,
    VIRTIO_CMD_CREATE_UC,
    VIRTIO_CMD_DEALLOC_UC,
    VIRTIO_CMD_QUERY_PKEY,
    VIRTIO_CMD_ADD_GID,
    VIRTIO_CMD_DEL_GID,
    VIRTIO_CMD_REQ_NOTIFY_CQ,
    VIRTIO_CMD_IW_ACCEPT,
    VIRTIO_CMD_IW_CONNECT,
    VIRTIO_CMD_IW_CREATE_LISTEN,
    VIRTIO_CMD_IW_DESTROY_LISTEN,
    VIRTIO_CMD_IW_REJECT,
    VIRTIO_CMD_CREATE_SRQ, /* RESERVED */
    VIRTIO_CMD_MODIFY_SRQ, /* RESERVED */
    VIRTIO_CMD_QUERY_SRQ, /* RESERVED */
    VIRTIO_CMD_DESTROY_SRQ, /* RESERVED */
    VIRTIO_CMD_RESERVED_START, /* RESERVED */
    VIRTIO_CMD_RESERVED_END = 128
};
\end{lstlisting}

\subsubsection{controlq Operation: Query Port}\label{sec:Device Types / RDMA Device / controlq Operation / Query Port}

Query the port's attrs from host. The command equals to VIRTIO_CMD_QUERY_PORT.
The request data is struct cmd_query_port; the response data is struct resp_query_port.

\begin{lstlisting}
struct cmd_query_port {
    /* port number */
    uint8_t port;
};

enum ib_port_state {
    IB_PORT_NOP = 0,
    IB_PORT_DOWN = 1,
    IB_PORT_INIT = 2,
    IB_PORT_ARMED = 3,
    IB_PORT_ACTIVE = 4,
    IB_PORT_ACTIVE_DEFER = 5
};

enum ib_mtu {
    IB_MTU_256 = 1,
    IB_MTU_512 = 2,
    IB_MTU_1024 = 3,
    IB_MTU_2048 = 4,
    IB_MTU_4096 = 5
};

struct rsp_query_port {
    /* Logical port state */
    enum ib_port_state state;
    /* Max MTU supported by port */
    enum ib_mtu max_mtu;
    /* Actual MTU */
    enum ib_mtu active_mtu;
    /* Length of source GID table */
    int gid_tbl_len;
    /* Use ip based gids */
    unsigned int ip_gids;
    /* Port capabilities */
    u32 port_cap_flags;
    /* Maximum message size */
    u32 max_msg_sz;
    /* Bad P_Key counter */
    u32 bad_pkey_cntr;
    /* Q_Key violation counter */
    u32 qkey_viol_cntr;
    /* Length of partition table */
    u16 pkey_tbl_len;
    /* SM LID */
    u32 sm_lid;
    /* Base port LID */
    u32 lid;
    /* LMC of LID */
    u8 lmc;
    /* Maximum number of VLs (Virtual Lanes) */
    u8 max_vl_num;
    /* SM service level */
    u8 sm_sl;
    /* Subnet propagation delay */
    u8 subnet_timeout;
    /* Type of initialization performed by SM */
    u8 init_type_reply;
    /* Currently active link width */
    u8 active_width;
    /* Currently active link speed */
    u16 active_speed;
    /* Physical port state */
    u8 phys_state;
    u16 port_cap_flags2;
};
\end{lstlisting}

The port_cap_flags is defined in following:

% TODO
\begin{lstlisting}
/* PortInfo CapabilityMask */
enum ib_port_capability_mask_bits {
    /* The SM sends packet from this port */ 
    VIRTIO_IB_PORT_SM = 1 << 1,
    /* This port supports notices */
    VIRTIO_IB_PORT_NOTICE_SUP = 1 << 2,
    /* This port supports trap */
    VIRTIO_IB_PORT_TRAP_SUP = 1 << 3,
    /* This port supports Inter Packet Delay optional values */
    VIRTIO_IB_PORT_OPT_IPD_SUP = 1 << 4,
    /* This port supports Automatic Path Migration */
    VIRTIO_IB_PORT_AUTO_MIGR_SUP = 1 << 5,
    /* This port supports SL to VL mapping table */
    VIRTIO_IB_PORT_SL_MAP_SUP = 1 << 6,
    /* This port supports saving the M_Key in Non Volatile RAM */
    VIRTIO_IB_PORT_MKEY_NVRAM = 1 << 7,
    /* This port supports saving the P_KEY table in Non Volatile RAM */
    VIRTIO_IB_PORT_PKEY_NVRAM = 1 << 8,
    /* This port supports turning on/off the LEDs using management packets */
    VIRTIO_IB_PORT_LED_INFO_SUP = 1 << 9,
    /* SM isn't disabled on this port */
    VIRTIO_IB_PORT_SM_DISABLED = 1 << 10,
    /* This port supports system image GUID */
    VIRTIO_IB_PORT_SYS_IMAGE_GUID_SUP = 1 << 11,
        IB_PORT_PKEY_SW_EXT_PORT_TRAP_SUP = 1 << 12,
        IB_PORT_EXTENDED_SPEEDS_SUP = 1 << 14,
        IB_PORT_CAP_MASK2_SUP = 1 << 15,
        IB_PORT_CM_SUP = 1 << 16,
        IB_PORT_SNMP_TUNNEL_SUP = 1 << 17,
        IB_PORT_REINIT_SUP = 1 << 18,
        IB_PORT_DEVICE_MGMT_SUP = 1 << 19,
        IB_PORT_VENDOR_CLASS_SUP = 1 << 20,
        IB_PORT_DR_NOTICE_SUP = 1 << 21,
        IB_PORT_CAP_MASK_NOTICE_SUP = 1 << 22,
        IB_PORT_BOOT_MGMT_SUP = 1 << 23,
        IB_PORT_LINK_LATENCY_SUP = 1 << 24,
        IB_PORT_CLIENT_REG_SUP = 1 << 25,
        IB_PORT_OTHER_LOCAL_CHANGES_SUP = 1 << 26,
        IB_PORT_LINK_SPEED_WIDTH_TABLE_SUP = 1 << 27,
        IB_PORT_VENDOR_SPECIFIC_MADS_TABLE_SUP = 1 << 28,
        IB_PORT_MCAST_PKEY_TRAP_SUPPRESSION_SUP = 1 << 29,
        IB_PORT_MCAST_FDB_TOP_SUP = 1 << 30,
        IB_PORT_HIERARCHY_INFO_SUP = 1ULL << 31,
};
\end{lstlisting}

\subsubsection{controlq Operation: Create CQ}\label{sec:Device Types / RDMA Device / controlq Operation / Create CQ}

Create a Completion Queue (CQ) in host. The command equals to VIRTIO_CMD_CREATE_CQ.
Request data is struct cmd_create_cq; response data is struct rsp_create_cq.

The driver MUST fill the completion virtqueue with buffers.

\begin{lstlisting}
struct cmd_create_cq {
    /* Size of CQ */
    u32 cqe;
};

struct rsp_create_cq {
    /* Created CQ handle */
    u32 cqn;
};
\end{lstlisting}

\subsubsection{controlq Operation: Destroy CQ}\label{sec:Device Types / RDMA Device / controlq Operation / Destroy CQ}

Destroy a Completion Queue (CQ) in host. The command equals to VIRTIO_CMD_DESTROY_CQ.
Request data is struct cmd_destroy_cq; no response data.

% TODO
The device MUST reset the virtqueue after destroying the CQ.

The driver MUST reset the virtqueue after destroying the CQ.

\begin{lstlisting}
struct cmd_destroy_cq {
    /* CQ need to be destroyed */
    u32 cqn;
};
\end{lstlisting}

\subsubsection{controlq Operation: Create PD}\label{sec:Device Types / RDMA Device / controlq Operation / Create PD}

Create a Protection Domain (PD) in host. The command equals to VIRTIO_CMD_CREATE_PD.
Request data is struct cmd_create_pd; response data is struct rsp_create_pd.

\begin{lstlisting}
struct cmd_create_pd {
    /* context created by VIRTIO_CMD_CREATE_UC */
    u32 ctx_handle;
};

struct rsp_create_pd {
    /* Created PD handle */
    u32 pdn;
};
\end{lstlisting}

\subsubsection{controlq Operation: Destroy PD}\label{sec:Device Types / RDMA Device / controlq Operation / Destroy PD}

Destroy a Protection Domain (PD) in host. The command equals to VIRTIO_CMD_DESTROY_PD.
Request data is struct cmd_destroy_qp; no response data.

\begin{lstlisting}
struct cmd_destroy_pd {
    /* PD needs to be destroyed */
    u32 pdn;
};
\end{lstlisting}

\subsubsection{controlq Operation: Get DMA MR}\label{sec:Device Types / RDMA Device / controlq Operation / Get DMA MR}

Get a DMA Memory Region(MR) from host. The command equals to VIRTIO_CMD_GET_DMA_MR.
Request data is struct cmd_create_mr, response data is struct rsp_create_mr.

\begin{lstlisting}
struct cmd_create_mr {
    /* PD which the MR associated with */
    u32 pdn;
    /* MR's protection attributes */
    u32 access_flags;
    /* Maximum number of scatter list */
    u32 max_num_sg;
};

struct rsp_create_mr {
    /* Created MR handle */
    u32 mrn;
    /* MR's local access key */
    u32 lkey;
    /* MR's remote access key */
    u32 rkey;
};
\end{lstlisting}

\subsubsection{controlq Operation: Create MR}\label{sec:Device Types / RDMA Device / controlq Operation / Create MR}

Create a Memory Region(MR) in host. The command equals to VIRTIO_CMD_CREATE_MR.
Request data is struct cmd_create_mr, response data is struct rsp_create_mr.

\begin{lstlisting}
struct cmd_create_mr {
    /* PD which the MR associated with */
    u32 pdn;
    /* MR's protection attributes */
    u32 access_flags;
    /* Maximum number of scatter list */
    u32 max_num_sg;
};

struct rsp_create_mr {
    /* Created MR handle */
    u32 mrn;
    /* MR's local access key */
    u32 lkey;
    /* MR's remote access key */
    u32 rkey;
};
\end{lstlisting}

\subsubsection{controlq Operation: Map MR s/g}\label{sec:Device Types / RDMA Device / controlq Operation / Map MR s/g}

Map scatter list to MR in host. The command equals to VIRTIO_CMD_MAP_MR_SG.
Request data is struct cmd_map_mr_sg, response data is struct rsp_map_mr_sg.

\begin{lstlisting}
struct cmd_map_mr_sg {
    /* MR maps to */
    u32 mrn;
    /* Start address of MR */
    u64 start;
    /* Num pages need to map */
    u32 npages;
    /* Two-level page table's DMA address */
    u64 pages;
};

struct rsp_map_mr_sg {
    /* Num pages has been map */
    u32 npages;
};
\end{lstlisting}

\subsubsection{controlq Operation: Register User MR}\label{sec:Device Types / RDMA Device / controlq Operation / Register User MR}

Register a user MR in host. The command equals to VIRTIO_CMD_REG_USER_MR.
Request data is struct cmd_reg_user_mr, response data is struct rsp_reg_user_mr.

\begin{lstlisting}
struct cmd_reg_user_mr {
    /* PD which the MR associated with */
    u32 pdn;
    /* MR's protection attributes */
    u32 access_flags;
    /* Start address of MR */
    u64 start;
    /* Length of MR */
    u64 length;
    /* Two-level page table's DMA address */
    u64 pages;
    /* Num pages in page table */
    u32 npages;
};

struct rsp_reg_user_mr {
    /* MR handle */
    u32 mrn;
    /* MR's local access key */
    u32 lkey;
    /* MR's remote access key */
    u32 rkey;
};
\end{lstlisting}

\subsubsection{controlq Operation: Deregister MR}\label{sec:Device Types / RDMA Device / controlq Operation / Deregister MR}

Deregister the MR in host. The command equals to VIRTIO_CMD_DEREG_MR.
Request data is struct cmd_dereg_mr, no response data.

is_user_mr MUST set to 1 if mr is created by VIRTIO_CMD_REG_USER_MR and
MUST set to 0 if mr is created by VIRTIO_CMD_CREATE_MR and VIRTIO_CMD_GET_DMA_MR.

\begin{lstlisting}
struct cmd_dereg_mr {
    /* MR needs to be destroyed */
    u32 mrn;
    /* Is user space MR */
    u8 is_user_mr;
};
\end{lstlisting}

\subsubsection{controlq Operation: Create QP}\label{sec:Device Types / RDMA Device / controlq Operation / Create QP}

Create a Queue Pair(QP) in host. The command equals to VIRTIO_CMD_CREATE_QP.
Request data is struct cmd_create_qp, response data is rsp_create_qp.

The driver SHOULD assign a pair of virtqueues to the queue pair, and the virtqueues SHOULD NOT be reused.

\begin{lstlisting}
struct cmd_create_qp {
    /* QP which the QP associated with */
    u32 pdn;
    /* QP's type */
    u8 qp_type;
    /* Size of SQ */
    u32 max_send_wr;
    /* Max number of sge in send_wr */
    u32 max_send_sge;
    /* CQ which the SQ associated with */
    u32 send_cqn;
    /* Size of RQ */
    u32 max_recv_wr;
    /* Max number of sge in recv_wr */
    u32 max_recv_sge;
    /* CQ which the RQ associated with */
    u32 recv_cqn;
    /* Use SRQ */
    u8 is_srq;
    /* SRQ which the QP associated with */
    u32 srq_handle;
};

struct rsp_create_qp {
    /* Created QP handle */
    u32 qpn;
};
\end{lstlisting}

\subsubsection{controlq Operation: Modify QP}\label{sec:Device Types / RDMA Device / controlq Operation / Modify QP}

Modify the QP in host. The command equals to VIRTIO_CMD_MODIFY_QP.
Request data is struct cmd_modify_qp, no response data.

\begin{lstlisting}
struct cmd_modify_qp {
    /* QP needs to be modified */
    u32 qpn;
    /* Attributes need to be modified */
    u32 attr_mask;
    /* QP's attributes need to be modified to */
    struct virtio_rdma_qp_attr attrs;
};
\end{lstlisting}

\subsubsection{controlq Operation: Query QP}\label{sec:Device Types / RDMA Device / controlq Operation / Query QP}

Query the QP from host. The command equals to VIRTIO_CMD_QUERY_QP.
Request data is struct cmd_query_qp, response data is struct rsp_query_qp.

\begin{lstlisting}
struct cmd_query_qp {
    /* QP needs to be queried */
    u32 qpn;
    /* Attributes need to be queried */
    u32 attr_mask;
};

struct rsp_query_qp {
    /* QP's attributes */
    struct virtio_rdma_qp_attr attr;
};
\end{lstlisting}

\subsubsection{controlq Operation: Destroy QP}\label{sec:Device Types / RDMA Device / controlq Operation / Destroy QP}


Destroy the QP in host. The command equals to VIRTIO_CMD_DESTROY_QP.
Request data is struct cmd_destroy_qp, no response data.

% TODO
The driver MUST reset the virtqueue after destroying the QP.

The device MUST reset the virtqueue after destroying the QP.

\begin{lstlisting}
struct cmd_destroy_qp {
    /* QP needs to be destroyed */
    u32 qpn;
};
\end{lstlisting}

\subsubsection{controlq Operation: Create UC}\label{sec:Device Types / RDMA Device / controlq Operation / Create UC}

Create a user context in host. The command equals to VIRTIO_CMD_CREATE_UC.
No request data, response data is struct rsp_create_uc.

\begin{lstlisting}
struct rsp_create_uc {
    /* Context handle */
    u32 ctx_handle;
};
\end{lstlisting}

\subsubsection{controlq Operation: Dealloc UC}\label{sec:Device Types / RDMA Device / controlq Operation / Dealloc UC}

Dealloc the user context in host. The command equals to VIRTIO_CMD_DEALLOC_UC.
Request data is struct cmd_dealloc_uc; no response data.

\begin{lstlisting}
struct cmd_dealloc_uc {
    /* Context needs to be dealloced */
    u32 ctx_handle;
};
\end{lstlisting}

\subsubsection{controlq Operation: Query Pkey}\label{sec:Device Types / RDMA Device / controlq Operation / Query Pkey}

Query pkey from host. The command equals to VIRTIO_CMD_QUERY_PKEY.
Request data is struct cmd_query_pkey; response data is struct rsp_query_pkey.

\begin{lstlisting}
struct cmd_query_pkey {
    /* Port to be queried */
    u32 port;
    /* Index of pkey */
    u16 index;
};

struct rsp_query_pkey {
    /* Pkey */
    u16 pkey;
};
\end{lstlisting}

\subsubsection{controlq Operation: Add GID}\label{sec:Device Types / RDMA Device / controlq Operation / Add GID}

Regist a gid in host. The command equals to VIRTIO_CMD_ADD_GID.
Request data is struct cmd_add_gid; no response data.

\begin{lstlisting}
struct cmd_add_gid {
    /* Gid needs to be added */
    u8 gid[16];
    /* Type of gid */
    u32 gid_type;
    /* Index of gid */
    u16 index;
    /* Port needs to be added to */
    u32 port_num;
};
\end{lstlisting}

\subsubsection{controlq Operation: Delete GID}\label{sec:Device Types / RDMA Device / controlq Operation / Delete GID}

Delete a gid in host. The command equals to VIRTIO_CMD_DEL_GID.
Request data is struct cmd_del_gid; no response data.

\begin{lstlisting}
struct cmd_del_gid {
    /* Index of gid */
    u16 index;
    /* Port needs to be deleted from */
    u32 port;
};
\end{lstlisting}

\subsubsection{controlq Operation: Request Notify CQ}\label{sec:Device Types / RDMA Device / controlq Operation / Request Notify CQ}

Request notify in cq. The command equals to VIRTIO_CMD_REQ_NOTIFY_CQ.
Request data is struct cmd_req_notify; no response data.

\begin{lstlisting}
struct cmd_req_notify {
    /* CQ to be requested */
    u32 cqn;
    /* Notify flags */
    u32 flags;
};
\end{lstlisting}

\subsection{Device Operation: Send Queue Operation}\label{sec:Device Types / RDMA Device / Send Queue Operation}

The driver queues send requests to the virtqueue which belongs to the queue pair.

Requests have the following format:

\begin{lstlisting}
struct virtio_rdma_sq_req {
    /* Device-readable part */
    struct cmd_post_send {
        /* QP which the request posted to */
        u32 qpn;
        /* Post from kernel */
        u32 is_kernel;
        /* Length of sg_list */
        u32 num_sge;
    
        int send_flags;
        /* Work request opcode */
        enum ib_wr_opcode opcode;
        /* Work request ID */
        u64 wr_id;
    
        union {
            /* Immediate data to send */
            be32 imm_data;
            /* Remote key of MR need to be invalidated */
            u32 invalidate_rkey;
        } ex;
        
        union {
            struct {
                /* Remote address */
                u64 remote_addr;
                /* Remote key of MR */
                u32 rkey;
            } rdma;
            struct {
                /* Remote address */
                u64 remote_addr;
                /* Atomic compare and add */
                u64 compare_add;
                /* Atomic swap */
                u64 swap;
                /* Remote key of MR */
                u32 rkey;
            } atomic;
            struct {
                /* Remote QP number */
                u32 remote_qpn;
                /* Remote qkey */
                u32 remote_qkey;
                struct virtio_rdma_av {
                    /* Port of AV */
                    u32 port;
                    /* PD number of AV */
                    u32 pdn;
                    /* Service Level, Traffic Class, FLow Label */
                    u32 sl_tclass_flowlabel;
                    /* destination GID */
                    u8 dgid[16];
                    /* Source Path Bits */
                    u8 src_path_bits;
                    /* Index of gid */
                    u8 gid_index;
                    /* Rate limit */
                    u8 static_rate;
                    /* Hop limit of packet */
                    u8 hop_limit;
                    /* Destination mac */
                    u8 dmac[6];
                    /* Reserved */
                    u8 reserved[6];
                } av;
            } ud;
            struct {
                /* MR handle */
                u32 mrn;
                /* Key of MR */
                u32 key;
                /* Protection attributes of MR */
                int access;
            } reg;
        } wr;
    } cmd;
    struct sge {
        /* Start address */
        u64 addr;
        /* Memory length */
        u32 length;
        /* Memory's local access key */
        u32 lkey;
    } sg_list[];
};
\end{lstlisting}

The length of sg_list MUST equal to cmd.num_sge.

\subsection{Device Operation: Receive Queue Operation}\label{sec:Device Types / RDMA Device / Receive Queue Operation}

The driver queues receive queue requests to the virtqueue which belongs to the queue pair.

Requests have the following format:

\begin{lstlisting}
struct virtio_rdma_rq_req {
    // Device-readable part
    struct cmd_post_recv {
        /* QP which the request posted to */
        u32 qpn;
        /* Post from kernel */
        u32 is_kernel;
        /* Length of sg_list */
        u32 num_sge;
        /* Work request ID */
        u64 wr_id;
    } cmd;
    struct sge {
        /* Start address */
        u64 addr;
        /* Memory length */
        u32 length;
        /* Memory's local access key */
        u32 lkey;
    } sg_list[];
};
\end{lstlisting}

The length of sg_list MUST equal to cmd.num_sge.

\subsection{Device Operation: Complete Queue Operation}\label{sec:Device Types / RDMA Device / Complete Queue Operation}

The driver SHOULD fill the virtqueue with buffers before use it.

The device pop a buffer from virtqueue, fill it and push back while getting a completion queue element.

Requests have the following format:

\begin{lstlisting}
struct virtio_rdma_cq_req {
    // Device-writable part
    uint64_t        wr_id; /* Work request ID */
    enum ib_wc_status status; /* Work completion status */
    enum ib_wc_opcode opcode; /* Word request opcode */
    uint32_t vendor_err; /* error */
    uint32_t byte_len;
    union {
        uint32_t imm_data;
        uint32_t invalidate_rkey;
    }ex;
    /* QP handle */
    uint32_t qp_num;
    /* Source QP */
    uint32_t src_qp;
    /* Work completion flag */
    int  wc_flags;
    /* Index of pkey */
    uint16_t pkey_index;
    /* Source LID */
    uint16_t slid;
    /* Service Level */
    uint8_t sl;
    /* Destination LID path bits */
    uint8_t dlid_path_bits;
    /* Port number */
    uint8_t port_num;
};
\end{lstlisting}
